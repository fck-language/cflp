# Context free language parser

This crate provides functionality for parsing context-free languages and was written for use with [fck](https://github.com/fck-language/fck).

## Usage

This crate provides the `rule!` macro to enable parsing context-free languages. The macro is quite powerful so we recommend you have a look at the [documentation](https://fck-language.com/cflp).

the crate also provides the `Parser` trait and `Error` struct returned when the `Parser::parse` function encounters an error.

### Trait impl requirements

There are three trait requirements for the two types which we'll call `T` for the input type (the input iterator into the parse functions has type `F: Iter<Item=&T>`) and `E` for the comparison type:
1. `E: PartialEq<E>`
2. `&T: PartialEq<E>`
3. `Option<&T>: PartialEq<E>`

The saved values in the resulting structs must also implement the derived traits given to the macro. For example, you can derive `Copy` if you store a `u8` but not a `String`.

## Examples

The [examples](examples) directory contains some example files with generated expansions. These are generated using [`cargo-expand`](https://crates.io/crates/cargo-expand) without the expansion of the derived traits.

All the examples have has some manual formatting of line breaks and some comments to indicate which section is currently being parser.

The structure of the examples is the same for all of them:
1. Two enums for `TokenType` and `Token` along with required implementations
2. `mod example` which has the `rule!` macro call. Above each rule will be a comment indicating the generated struct type for that rule
3. `mod equivalent` which has the equivalent code generated by the macro

## Current issues

- You can't currently partially match the value of an enum variant. For example, if you wanted to match `EnumName::Variant(T, E)` where the first value was some specific value and then save the second value similarly to
  ```rust
  if let EnumName::Variant(1, a) = var_to_check { f(a) }
  ```
- Enum type rules can't currently have custom names
- Types are all generated. This means no type hints in an IDE. An option of having pre-generated types will be added later
- Calling other functions (an identifying feature of CFLs) is not currently implemented. I'm working on it
- Errors are a bit rudimentary at the moment. If you consider the rule `(Token::T1)?, Token::T2`, the first token could be either `Token::T1` or `Token::T2`. If neither of thee are found then the returned error will say it expected `Token::T2`. A future version wil have better errors where the `expected` is a `Vec<E>` that will be calculated for each possible error position for more useful errors 
