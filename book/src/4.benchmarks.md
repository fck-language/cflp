# Benchmarks

Because cflp is for parsing a context-free language from a token stream into an AST, we have two primary aims:

1. **Correctness**\
    The derived `Parser` impls must be correct. This is a simple pass/fail aim
2. **Speed**\
    The derived `Parser` impls must be as fast as then can be made

To compare the speed of the derived impls, we use [criterion](https://github.com/bheisler/criterion.rs) v0.4.0 and two benchmark groups; a simple and complex benchmark.

## Simple benchmark

[Benchmark](https://fck-language.github.io/cflp/bench/Simple/report) | [Handwritten](https://fck-language.github.io/cflp/bench/Simple/handwritten/report) | [Derived](https://fck-language.github.io/cflp/bench/Simple/derived/report)

The simple benchmark doesn't use wrapping and uses fairly simple rules. This is used to check that the derived impl is fast in a base case. It is also useful as a base benchmark to compare with other benchmarks to remove some variability from test-to-test.

## Complex benchmark

[Benchmark](https://fck-language.github.io/cflp/bench/Complex/report) | [Handwritten](https://fck-language.github.io/cflp/bench/Complex/handwritten/report) | [Derived](https://fck-language.github.io/cflp/bench/Complex/derived/report)

The complex benchmark uses wrapping (`NodeWrapper`) with repeating sections and boxed matches. This is used to compare a handwritten impl against a derived one. Ideally, the derived impl would be as good as the handwritten one, but this is not true as of writing.

## Comparing results

The results are used to compare the efficiency of the derived impls relative to the handwritten ones. Benchmarks are not intended to be used to compare absolute times.

> As a note, all of the files generated by criterion are available under the criterion path of this book (https://fck-language.github.io/cflp/bench)
