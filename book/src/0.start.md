# Getting started

Welcome to the cflp book. This is to teach you how to use cflp and contains some [benchmarks](https://fck-language.github.io/cflp/bench/report) (More on that [later](./4.benchmarks.md))

---

To start, make sure you've added the library to your `Cargo.toml` file

```toml
cflp = "1.0"
```

## Overview

cflp allows you to derive a parser trait with a derive macro and helper attributes. The macro can derive a context-free language (hence the name of the crate), but the trait can be used more generally if required.

When discussing the trait, we have three types to consider:

`I`: Input type

`C` : Comparison type

`B`: Scope type

The parser takes an iterator over input tokens which are of type `I` and compares them to some instances of the type `C`. These may be the same type in simple instances, but for more complex uses will most likely be different types.

## Required impls

```rust
pub trait Parser<I, C: PartialEq<C>, B, R = Self> where Self: Scope<B> {
    fn parse<T: Iterator<Item=I> + Clone>(src: &mut T) -> Result<R, Error<I, C, B>>
        where Self: Sized
    {
        <Self as Parser<I, C, B, R>>::parse_with_recursion(src, true)
    }

    fn parse_with_recursion<T: Iterator<Item=I> + Clone>(
        src: &mut T, recurse: bool
    ) -> Result<R, Error<I, C, B>> where Self: Sized;
}
```

When deriving the `Parser` trait, you will need to ensure that your input type `I` implements `PartialEq<C>` where `C` is your comparison type (this will make sense the more you read). You will also need to ensure that `C: PartialEq<C>`.

**IMPORTANT:**
If the input and comparison types are given as the same thing, deriving `PartialEq` on the input type will not cover the requirement `I: PartialEq<C>`. Since the input comes from an iterator, `I` will be a reference. If the input and comparison types are given as the same, then `I = &C`. In this case, you will need to impl `&C: PartialEq<C>`. You can use the `PartiqlEqRef` derive macro to derive a simple impl for this:

```rust
impl PartialEq<C> for &C {
    fn eq(&self, other: &C) -> bool {
        self == other
    }
}
```

## Errors and scoping

The scope type is for errors. If we have two types `E1` and `E2` that both implement `Parser`, with `E1::parse` at some point calling `E2::parse`, we might want to know that, if an error occurs in parsing `E2`, how we got there. To do this we have the `scope` field on the `Error` struct:

```rust
pub struct Error<F, E, B> {
    pub found: Option<F>,
    pub expected: E,
    pub scope: Vec<B>
}

pub trait Scope<B> {
    fn scope() -> B;
}
```

If we got an error in `E2`, the `scope` field would(should) be `vec![<E2 as Scope<B>>::scope(), <E1 as Scope<B>>::scope()]`. This way we can find out where the error came from.

### Handling scoping with custom impls

If you write an impl instead of deriving it, if you ever make a call to a `Parser::parse` function, when handling an error from that call, make sure to push a new scope to the error if you plan to return it. You can use `Error::<F, E, B>::push_scope(&mut self, scope: B)` to do this. For example (using types from [example 3](https://github.com/fck-language/cflp/tree/master/examples/example3.rs))

```rust
impl<'a> cflp::Parser<&'a Token, TokType, NodeType, cflp::NodeWrapper<Expr, usize>> for NewNode {
    fn parse_with_recursion<T: Iterator<Item = &'a Token> + Clone>(
        src: &mut T,
        recurse: bool,
    ) -> Result<cflp::NodeWrapper<Expr, usize>, cflp::Error<&'a Token, TokType, NodeType>> {
        /* ... */
        match SomeOtherNode::parse(src) {
            Ok(n) => { /* ... */ }
            Err(mut e) => {
                e.push_scope(<Self as Scope<NodeType>>::scope());
                return Err(e)
            }
        }
        /* ... */
    }
}
```
