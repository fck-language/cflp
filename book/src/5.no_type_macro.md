# No type generation required

If you already have the types you want to use, you can either derive the `Parser` impl for the type or use the `rule_no_types!` macro.

## `rule_no_types!`

The `rule_no_types!` macro is exactly the same as the `rule!` macro without the requirement for the type visibility, and won't generate type.

For example the following two code blocks are equivalent

```rust
rule!(
	(pub(crate), Token, Token, |t| t.clone(), (Debug, Clone))
	(Root; Token::OP, ([@Expr])*, Token::CP)
	(Expr; Literal => [Token::Literal; u8]; [Token::Other; char])
);
```

```rust
#[derive(Debug, Clone)]
pub(crate) struct Root(Expr);

#[derive(Debug, Clone)]
pub(crate) enum Expr {
    Literal(u8),
    Var2(char)
}

rule_no_types!(
	(Token, Token, |t| t.clone(), (Debug, Clone))
	(Root; Token::OP, ([@Expr])*, Token::CP)
	(Expr; Literal => [Token::Literal; u8]; [Token::Other; char])
);
```

This may be useful to you for additional type hints in an IDE or to see the types more easily.

## Attribute macro

An attribute macro is the other way you can derive the `Parser` impl from a rule. If you wanted to use this for the previous example, this is what you'd have

```rust
#[derive(Debug, Clone)]
#[parser(Token, Token, |t| t.clone(); Token::OP, ([@Expr])*, Token::CP)]
pub(crate) struct Root(Expr);

#[derive(Debug, Clone)]
#[parser(Token, Token, |t| t.clone())]
pub(crate) enum Expr {
    #[parser([Token::Literal; u8])]
    Literal(u8),
    #[parser([Token::Other; char])]
    Var2(char)
}
```

You'll notice a different form of the macro for an enum and struct; structs have all the required data provided in a single macro, whereas enums define any general data along with the enum definition and define the rules above each variant. This adds some readability to the code but also ensures that the number of rules and the number of enums can be matched easier both visually and by the macro.

This method in general improves the readability of the macro but does require that all generic data (iterator item etc.) be redeclared for each node type. It also requires that types be updated if the parser rule is changed.
