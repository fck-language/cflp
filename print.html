<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Context-Free-Language Parser</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Intro</a></li><li class="spacer"></li><li class="chapter-item expanded "><a href="0.start.html"><strong aria-hidden="true">1.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="1.non-macro-lib.html"><strong aria-hidden="true">2.</strong> Non-macro library overview</a></li><li class="chapter-item expanded "><a href="2.derive.html"><strong aria-hidden="true">3.</strong> Simple derive macro</a></li><li class="chapter-item expanded "><a href="3.node-data.html"><strong aria-hidden="true">4.</strong> Node data (complex version)</a></li><li class="spacer"></li><li class="chapter-item expanded affix "><a href="4.benchmarks.html">Benchmarks</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Context-Free-Language Parser</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="context-free-language-parser"><a class="header" href="#context-free-language-parser">Context-Free Language Parser</a></h1>
<p>This book will show you how to use the <code>#[derive(Parser)]</code> proc-macro to generate a <a href="https://docs.rs/cflp/1.0.0/cflp/trait.Parser.html"><code>Parser</code></a> trait implementation to allow for parsing context-free languages.</p>
<p>The book is split into three parts:</p>
<ol>
<li>General introduction (sections <a href="0.start.html">1</a> and <a href="1.non-macro-lib.html">2</a>)</li>
<li>Simple usage (section <a href="2.derive.html">3</a>)</li>
<li>Expanded usage (section <a href="3.node-data.html">4</a>)</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<p>Welcome to the cflp book. This is to teach you how to use cflp and contains some <a href="https://fck-language.github.io/cflp/bench/report">benchmarks</a> (More on that <a href="./4.benchmarks.html">later</a>)</p>
<hr />
<p>To start, make sure you've added the library to your <code>Cargo.toml</code> file</p>
<pre><code class="language-toml">cflp = &quot;1.0&quot;
</code></pre>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>cflp allows you to derive a parser trait with a derive macro and helper attributes. The macro can derive a context-free language (hence the name of the crate), but the trait can be used more generally if required.</p>
<p>When discussing the trait, we have two types to consider:</p>
<p><code>I</code>: Input type</p>
<p><code>C</code> : Comparison type</p>
<p>The parser takes an iterator over input tokens which are of type <code>I</code> and compares them to some instances of the type <code>C</code>. These may be the same type in simple instances, but for more complex uses will most likely be different types.</p>
<h2 id="required-impls"><a class="header" href="#required-impls">Required impls</a></h2>
<pre><code class="language-rust">pub trait Parser&lt;I, C, R = Self&gt; where
    I: PartialEq&lt;C&gt;,
    C: PartialEq&lt;C&gt;
{
	fn parse&lt;T&gt;(src: &amp;mut T) -&gt; Result&lt;R, Error&lt;I, C&gt;&gt; where
        I: Iterator&lt;Item=I&gt; + Clone,
        Self: Sized;
}</code></pre>
<p>When deriving the <code>Parser</code> trait, you will need to ensure that your input type <code>I</code> implements <code>PartialEq&lt;C&gt;</code> where <code>C</code> is your comparison type (this will make sense the more you read). You will also need to ensure that <code>C: PartialEq&lt;C&gt;</code>.</p>
<p><strong>IMPORTANT:</strong>
If the input and comparison types are given as the same thing, deriving <code>PartialEq</code> on the input type will not cover the requirement <code>I: PartialEq&lt;C&gt;</code>. Since the input comes from an iterator, <code>I</code> will be a reference. If the input and comparison types are given as the same, then <code>I = &amp;C</code>. In this case, you will need to impl <code>&amp;C: PartialEq&lt;C&gt;</code>. You can use the <code>PartiqlEqRef</code> derive macro to derive a simple impl for this:</p>
<pre><code class="language-rust">impl PartialEq&lt;C&gt; for &amp;C {
    fn eq(&amp;self, other: &amp;C) -&gt; bool {
        self == other
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="non-macro-library"><a class="header" href="#non-macro-library">Non-macro library</a></h1>
<p>In the non-macro part of the cflp library, we have two structs (<code>Error</code> and <code>NodeWrapper</code>), and two traits (<code>Parser</code> and <code>NodeData</code>)</p>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<h3 id="parser"><a class="header" href="#parser"><code>Parser</code></a></h3>
<pre><code class="language-rust">pub trait Parser&lt;I, C: PartialEq&lt;C&gt;, R = Self&gt; {
	fn parse&lt;T&gt;(src: &amp;mut T) -&gt; Result&lt;R, Error&lt;I, C&gt;&gt; where
            T: Iterator&lt;Item=I&gt; + Clone,
            Self: Sized {
        &lt;Self as Parser&lt;I, C, R&gt;&gt;::parse_with_recursion(false)
    }
    
    fn parse_with_recursion&lt;T&gt;(src: &amp;mut T) -&gt; Result&lt;R, Error&lt;I, C&gt;&gt; where
            T: Iterator&lt;Item=I&gt; + Clone,
            Self: Sized;
}</code></pre>
<p>The <code>Parser</code> trait is used to parse a token stream (of type <code>T</code>) into either a <code>Self</code> instance, or fail to do so and return an error.</p>
<p>You should only ever use <code>Parser::parse</code>. <code>Parser::parse_with_recursion</code> is where all the actual derived code goes. Without <code>parse_with_recursion</code>, we can end up with stack overflows. <code>parse_with_recursion</code> should prevent <a href="1.non-macro-lib.html#zero-consumption-branching">zero-consumption branching</a>.</p>
<h3 id="nodedata"><a class="header" href="#nodedata"><code>NodeData</code></a></h3>
<pre><code class="language-rust">pub trait NodeData&lt;T: Sized&gt; {
	fn start(&amp;self) -&gt; T;
	fn end(&amp;self) -&gt; T;
}</code></pre>
<p>The <code>NodeData</code> trait is used to obtain positional data about a node. This is intended for tokens used in the <a href="1.non-macro-lib.html#parser"><code>Parser</code></a> trait, but can be applied to parsed nodes as well.</p>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<h3 id="error"><a class="header" href="#error"><code>Error</code></a></h3>
<pre><code class="language-rust">pub struct Error&lt;F, E&gt; {
	pub found: Option&lt;F&gt;,
	pub expected: E
}</code></pre>
<p>The <code>Error</code> struct is returned from <a href="1.non-macro-lib.html#parser"><code>Parser::parse</code></a> when parsing fails. The <code>expected</code> field is for the element expected, and the <code>found</code> field is the element found. This is an <code>Option</code> because the iterator could return a <code>None</code>.</p>
<p>Here we'll introduce simple rule syntax. This will include matching types, optional sections, Kleene closures, and positive closures.</p>
<p>We'll be using the following struct as our example token</p>
<pre><code class="language-rust">pub enum Token {
    OB, CB,     // Opening and closing parenthesis
    Value(u8),  // A literal value
    Other(char) // Some character
}</code></pre>
<h2 id="matching-something"><a class="header" href="#matching-something">Matching something</a></h2>
<p>If you want to match a token, add the token you want to match to the rule. Simple as that. For example if we wanted to match <code>Token::OB</code> in our rule, we'd have <code>(RuleName; Token::OB)</code>.</p>
<h2 id="groups"><a class="header" href="#groups">Groups</a></h2>
<p>A group is a set of rules inside some parentheses. These can be complex nested groups with lots of modifiers applied to each inner group, or just contain a single value such as <code>(Token::Value(2))</code>.</p>
<h2 id="optional-sections"><a class="header" href="#optional-sections">Optional sections</a></h2>
<p>An optional section is one that can optionally be included in the input. The parser is a maximal-munch parser and will always try to match these optional sections.</p>
<p>To indicate an optional section, you add a <code>?</code> to the end of a <strong>group</strong> for example <code>(Token::Other('a'))?</code>.</p>
<h2 id="kleene-and-positive-closures"><a class="header" href="#kleene-and-positive-closures">Kleene and positive closures</a></h2>
<p>A Kleene closure is one that will match the inner section 0 or more times, and a positive closure will match the inner section at least once. These are indicated in a similar way to optional sections but with a <code>*</code> for a Kleene closure and <code>+</code> for a positive closure.</p>
<hr />
<h1 id="zero-consumption-branching"><a class="header" href="#zero-consumption-branching">Zero-consumption branching</a></h1>
<p>Consider the following:</p>
<pre><code class="language-rust">#[derive(PartialEq, PartialEqRef)]
enum Token {
    Add,
    Num(i64),
    Str(String)
}

#[derive(Parser)]
#[parser(Token, Token)]
enum Expr {
    #[parser([[@Expr]], Token::Add, [[@Expr]])]
    Add {
        left: Box&lt;Self&gt;,
        right: Box&lt;Self&gt;
    },
    #[parser([@ExprLit])]
    Literal(ExprLit)
}

#[derive(Parser)]
#[parser(Token, Token)]
enum ExprLit {
    #[parser([Token::Num(t)])]
    Number(i64),
    #[parser([Token::Str(t)])]
    String(String)
}</code></pre>
<p>This can lead to <em>zero-consumption branching</em> if we call <code>Expr::parse</code>, so-called because it consumes zero elements in <code>src</code> and branches the program. This is because it will try to first parse an <code>Expr</code>, leading to it trying to parse an <code>Expr</code> etc. resulting in a stack overflow. To prevent this we instead call <code>Parser::parse_with_recursion(src, false)</code> which is expected to prevent this call from trying to parse itself again.</p>
<p>This should not prevent calling <code>Parser::parse</code> for <code>Self</code> once something has been consumed.</p>
<p>If this is in your code, you will need to ensure that <code>C: Default</code>. This can be done for an enum by re-using one of the variants, since this is only required to have some value returned to prevent a stack overflow. See <a href="https://github.com/fck-language/cflp/blob/v1.0.1/examples/example3.rs">example 3</a> for an example of this.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="derive-macro"><a class="header" href="#derive-macro">Derive macro</a></h1>
<p>When using the derive macro to derive the <code>Parser</code> trait, you need to specify how the parser should be implemented. This is done using helper attributes (<code>#[parser(...)]</code>).</p>
<h2 id="metadata"><a class="header" href="#metadata">Metadata</a></h2>
<p>Metadata is just three arguments (two types and one expression) that are required to know how to derive the <code>Parser</code> impl. They're comma seperated (no trailing comma) and in the following order:</p>
<ol>
<li><strong>Input token type</strong> <code>I</code><br />
This is the type in the iterator (behind a reference). For example if our input token type was <code>MyToken</code>, the iterator would be <code>T: Iterator&lt;Item=&amp;MyToken&gt;</code></li>
<li><strong>Comparison token type</strong> <code>C</code><br />
This is the type being compared with. If your input token type contains token metadata (such as token position), then you will probably want to compare the underlying token type. Using the example from before, if we had <code>MyToken::type_: MyTokType</code> where <code>MyTokType</code> is an enum of token types, we would probably have our comparison token type as <code>MyTokType</code></li>
</ol>
<p><strong>IMPORTANT:</strong> If your input and comparison types are different, then <code>&amp;I: Into&lt;C&gt;</code> must be satisfied</p>
<h2 id="rule-syntax"><a class="header" href="#rule-syntax">Rule syntax</a></h2>
<p>Rules are defined as two parts; values and groups. Values are singular expressions, and groups are a group of values.</p>
<h3 id="values"><a class="header" href="#values">Values</a></h3>
<p>Consider the following rule from the <a href="https://github.com/fck-language/cflp/tree/master/examples/example1.rs">first example</a>:</p>
<pre><code class="language-rust">#[derive(Parser)]
#[parser(
    Token, Token;
    ([@Value])+, [@Sep], ([@Value])*, (@Sep)?)
]
pub struct Base {
    first: Vec&lt;Value&gt;,
    sep: Sep,
    last: Vec&lt;Value&gt;
}</code></pre>
<p>The first line in the helper attribute (line 3) is the metadata. The line after defines the rule for the parser impl. We'll consider this in segments:</p>
<ol>
<li><code>([@Value])+</code><br />
Firstly, <code>@Value</code> is a call to another rule, <code>Value</code> in this case. This will try to parse a <code>Value</code> type. Placing square brackets around this means that we save the match. The parentheses makes it a group and the <code>+</code> makes the group into a positive closure, meaning we match at least one <code>Value</code></li>
<li><code>[@Sep]</code><br />
This saves a <code>Sep</code> type that's matched the input</li>
<li><code>([@Value])*</code><br />
This is the same as <code>([@Value])+</code> but for a kleene closure, meaning we match zero or more <code>Value</code> types</li>
<li><code>(@Sep)?</code><br />
<code>@Sep</code> will match a <code>Sep</code> type. The <code>?</code> after the group means that this is optional, so it can either be matched or not</li>
</ol>
<blockquote>
<p>When saving values, you might need to box a value to ensure that the type has a known size at compile time. If this is required, you can use two square brackets to indicate as such. For example, <code>[[@Sep]]</code> would match a <code>Sep</code> type and box the result (<code>Box&lt;Sep&gt;</code>)</p>
</blockquote>
<h3 id="groups-1"><a class="header" href="#groups-1">Groups</a></h3>
<p>A group is a set of values in parentheses. It can optionally be followed by a <code>?</code>, <code>*</code>, or <code>+</code> for an optional group, kleene closure, and positive closure:</p>
<ul>
<li>Optional means it will try to be parsed. If it's not, then it resets the input iterator back to where it was before the group, and skips it. This becomes an <code>Option&lt;T&gt;</code> where <code>T</code> is the type matched by the inside of the group</li>
<li>Kleene closure means it matches any number (including zero) of the group. This becomes a <code>Vec&lt;T&gt;</code> where <code>T</code> is the type matched by the inside of the group</li>
<li>Positive closure means it matches at least one of the group. This has the same type as a kleene closure</li>
</ul>
<p>Groups can have comma seperated values. For example you could have <code>(TokType::Int(1), TokType::Add, TokType::Int(2))?</code> as a group. Groups can be nested</p>
<h3 id="enums-and-unwrapping-matches"><a class="header" href="#enums-and-unwrapping-matches">Enums and unwrapping matches</a></h3>
<p>Util now, all the examples have been on structs. Enums are slightly different. The enum needs the metadata in a parser attribute on the enum itself, with the rule for each enum variant in an parser attribute on the variant.</p>
<p>For example, we might have a simple enum to turn token literals into AST node literals</p>
<pre><code class="language-rust">#[derive(Parser)]
#[parser(Token, Token)]
pub enum Value {
    #[parser([Token::Digit(t)])]
    Int(usize),
    #[parser([Token::Ident(t)])]
    Ident(String)
}</code></pre>
<p>You'll notice that the matches on the variants don't have literal values, but identifiers. This is because matches that aren't calls to other types are parsed as patterns, like in a match statement arm. The identifiers are matches just like in a match statement and used, instead of matching the whole token.</p>
<p>When picking identifiers, make sure they're all unique. It's also a good idea to avoid identifiers with a double underscore prefix such as <code>__my_var</code> since double underscore prefixed variables are used in the derived implementation and it may allow for things to get messed up.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="node-data"><a class="header" href="#node-data">Node data</a></h1>
<p>When parsing, it's often useful to keep track of the positions of nodes for error handling for example. This can be achieved through the use the <code>NodeData</code> trait and the <code>NodeWrapper</code> struct.</p>
<p>The <code>NodeData</code> trait has two functions; <code>NodeData::start</code> and <code>NodeData::end</code> to get the start and end data of a node.</p>
<p>The <code>NodeWrapper</code> struct contains a node (<code>NodeWrapper::node</code>), and start and end data about that node (<code>NodeWrapper::start</code>, <code>NodeWrapper::end</code>).</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<pre><code class="language-rust">#[derive(Parser)]
#[parser(Token, TokType, |t| t.t, usize; ([@Add])*)]
pub struct Root(pub Vec&lt;NodeWrapper&lt;Add, usize&gt;&gt;);</code></pre>
<p>In this example, you'll notice that there is an additional field for the metadata. This indicates that any matches should be wrapped in a <code>NodeWrapper</code> struct with positional data. The type provided is the type returned from the <code>NodeData</code> trait functions<sup class="footnote-reference"><a href="#1">1</a></sup>.</p>
<p>You'll also notice that the inner section of the trait is not a <code>Vec&lt;Add&gt;</code>, but <code>Vec&lt;NodeWrapper&lt;Add, usize&gt;&gt;</code>.</p>
<h2 id="use-for-one-use-for-all"><a class="header" href="#use-for-one-use-for-all">Use for one, use for all</a></h2>
<p>If you derive one <code>Parser</code> impl that's wrapped, all <code>Parser</code> impls that can be called from the one using it must also be wrapped.</p>
<p>For example, you could not have the following</p>
<pre><code class="language-rust">#[derive(Parser)]
#[parser(Token, TokType, |t| t.t, usize; ([@Add])*)]
pub struct Root(pub Vec&lt;NodeWrapper&lt;Expr, usize&gt;&gt;);

#[derive(Parser)]
#[parser(Token, TokType, |t| t.t)]
pub enum Expr {
    /* ... */
}</code></pre>
<p>This would cause an error because the <code>Root</code> <code>Parser</code> impl would expect that the <code>Expr</code> <code>Parser</code> impl would also be wrapped so it can access the positional data of an <code>Expr</code> match.</p>
<h2 id="nodedata-impl-requirement"><a class="header" href="#nodedata-impl-requirement"><code>NodeData</code> impl requirement</a></h2>
<p>If you use wrapped matches, you need to ensure that the input type of your parser (<code>Token</code> in the example above) needs to implement <code>NodeData</code> so that <code>Parser</code> impls that match tokens not calls to other types can access positional data.</p>
<hr />
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>This could most likely be included as a generic in the <code>Parser</code> impl, but is required to ensure the correct <code>NodeData</code> impl is used in the case that there are multiple <code>NodeData</code> impls.</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmarks"><a class="header" href="#benchmarks">Benchmarks</a></h1>
<p>Because cflp is for parsing a context-free language from a token stream into an AST, we have two primary aims:</p>
<ol>
<li><strong>Correctness</strong><br />
The derived <code>Parser</code> impls must be correct. This is a simple pass/fail aim</li>
<li><strong>Speed</strong><br />
The derived <code>Parser</code> impls must be as fast as then can be made</li>
</ol>
<p>To compare the speed of the derived impls, we use <a href="https://github.com/bheisler/criterion.rs">criterion</a> v0.4.0 and two benchmark groups; a simple and complex benchmark.</p>
<h2 id="simple-benchmark"><a class="header" href="#simple-benchmark">Simple benchmark</a></h2>
<p><a href="https://fck-language.github.io/cflp/bench/Simple/report">Benchmark</a> | <a href="https://fck-language.github.io/cflp/bench/Simple/handwritten/report">Handwritten</a> | <a href="https://fck-language.github.io/cflp/bench/Simple/derived/report">Derived</a></p>
<p>The simple benchmark doesn't use wrapping and uses fairly simple rules. This is used to check that the derived impl is fast in a base case. It is also useful as a base benchmark to compare with other benchmarks to remove some variability from test-to-test.</p>
<h2 id="complex-benchmark"><a class="header" href="#complex-benchmark">Complex benchmark</a></h2>
<p><a href="https://fck-language.github.io/cflp/bench/Complex/report">Benchmark</a> | <a href="https://fck-language.github.io/cflp/bench/Complex/handwritten/report">Handwritten</a> | <a href="https://fck-language.github.io/cflp/bench/Complex/derived/report">Derived</a></p>
<p>The complex benchmark uses wrapping (<code>NodeWrapper</code>) with repeating sections and boxed matches. This is used to compare a handwritten impl against a derived one. Ideally, the derived impl would be as good as the handwritten one, but this is not true as of writing.</p>
<h2 id="comparing-results"><a class="header" href="#comparing-results">Comparing results</a></h2>
<p>The results are used to compare the efficiency of the derived impls relative to the handwritten ones. Benchmarks are not intended to be used to compare absolute times.</p>
<blockquote>
<p>As a note, all of the files generated by criterion are available under the criterion path of this book (https://fck-language.github.io/cflp/bench)</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
